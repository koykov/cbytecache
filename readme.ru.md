# CByteCache

Байтовый вытесняющий in-memory кэш, базирующийся на [cbyte](https://github.com/koykov/cbyte) библиотеке. Написан как
замена [bigcache](https://github.com/allegro/bigcache), но кардинально отличается от него организацией хранения данных и
множеством дополнительных функций, облегчающих работу в хайлоад проектах.

## Как работает

Модель хранения данных `bigcache` основана на хэш-таблице `map[uint64]uint32` для хранения ключей и огромных слайсов
`[]byte` для хранения данных. Это прекрасно помогает для нивелирования GC нагрузки, но избыточно с точки зрения экономии
памяти - так, однажды выделенный избыток памяти, никогда не будет освобождён. Для проектов с переменной нагрузкой это
весьма неоптимальный подход, т.к. память будет простаивать без пользы.

`cbytecache` использует ту же структуру для хранения ключей, но непосредственно байтовое хранилище использует диаметрально
противоположный подход - память разделена на небольшие арены фиксированного размера, а данные распределяются между ними.
Арены по необходимости могут выделяться, использоваться и освобождаться, что позволяет в каждый момент времени
использовать ровно столько памяти сколько необходимо. А для того, чтобы GC не аффектил производительность как кэша, так
и системы, арены используют библиотеку [cbyte](https://github.com/koykov/cbyte) для маскировки от GC. С точки срения GC
арена это просто [структура](https://github.com/koykov/cbytecache/blob/master/arena.go#L13), состоящая из числовых полей
и располагающаяся в стеке. Таким образом GC не будет никак проверять эту структуру.

На более высоком уровне, кэш разделён на шарды, называемые бакетами (bucket). У каждого бакета есть своя хэш-таблица
индексов и очередь арен. Это единственные указатели в кэше, поэтому когда GC начинает проверять кэш, то он увидит
несколько хэш-таблиц и слайсов примитивных структур и не будет ничего знать про огромные объёмы памяти, располагающиеся
в невидимой для него области. Очередь арен памяти будет рассмотрена в отдельном разделе ниже.

### Очередь арен памяти

Как уже упоминалось, `cbytecache` является вытесняющим кэшем, а в качестве минимальной единицы выделяемой памяти
используется арена. Все арены, выделяемые в пределах одного бакета, хранятся внутри специальной
[структуры](https://github.com/koykov/cbytecache/blob/master/arena_queue.go#L10), называемой очередью арен. Причём
последовательность арен в хранилище `buf` не отображает реальную последовательность в очереди. Каждая арена имеет
prev/next индексы, указывающие на соседние арены и они могут быть произвольными в пределах хранилища. Таким образом,
очередь арен представляет собой двусвязный список, но без указателей.

Когда наступает очередной цикл вытеснения устаревших данных, то определяется стартовый и конечный индексы арен,
содержащих устаревшие данные. Затем эти арены "переносятся" в конец очереди и считаются свободными, а их память далее
перезаписывается новыми данными по необходимости. Таким образом, очередь арен реализует циклическую очередь, причём
делает это очень дёшево - происходит замена нескольких prev/next индексов у арен.

Рассмотрим это на простом примере. Пусть у нас будет очередь, состоящая из 10-и арен и заполненная на 3/4:
```
buf:
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘

queue:
     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐
     │ id 0 │◄┐ ┌►│ id 1 │◄┐ ┌►│ id 2 │◄┐ ┌►│ id 3 │◄┐ ┌►│ id 4 │◄┐ ┌►│ id 5 │◄┐ ┌►│ id 6 │◄┐ ┌►│ id 7 │◄┐ ┌►│ id 8 │◄┐ ┌►│ id 9 │
x ◄──│ p -1 │ └─┼─│ p  0 │ └─┼─│ p  1 │ └─┼─│ p  2 │ └─┼─│ p  3 │ └─┼─│ p  4 │ └─┼─│ p  5 │ └─┼─│ p  6 │ └─┼─│ p  7 │ └─┼─│ p  8 │
     │ n  1 │───┘ │ n  2 │───┘ │ n  3 │───┘ │ n  4 │───┘ │ n  5 │───┘ │ n  6 │───┘ │ n  7 │───┘ │ n  8 │───┘ │ n  9 │───┘ │ n -1 │──► x
     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘
```
Как видно, у очереди:
- арена #0 является головой очереди (head)
- арена #9 является хвостом очереди (tail)
- арена #7 является актуальной (actual)
- пусть прошло какое-то количество времени и первые три арены содержат только устаревшие данные, т.е. арена #3 является нижней границей полезных данных (low)

Произошло выселение устаревших данных, в результете имеем вот такое состояние очереди:
```
buf:
┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │
└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘

queue:
     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐     ┌──────┐
     │ id 3 │◄┐ ┌►│ id 4 │◄┐ ┌►│ id 5 │◄┐ ┌►│ id 6 │◄┐ ┌►│ id 7 │◄┐ ┌►│ id 8 │◄┐ ┌►│ id 9 │◄┐ ┌►│ id 0 │◄┐ ┌►│ id 1 │◄┐ ┌►│ id 2 │
x ◄──│ p -1 │ └─┼─│ p  3 │ └─┼─│ p  4 │ └─┼─│ p  5 │ └─┼─│ p  6 │ └─┼─│ p  9 │ └─┼─│ p  8 │ └─┼─│ p  9 │ └─┼─│ p  0 │ └─┼─│ p  1 │
     │ n  4 │───┘ │ n  5 │───┘ │ n  6 │───┘ │ n  7 │───┘ │ n  8 │───┘ │ n  7 │───┘ │ n  0 │───┘ │ n  1 │───┘ │ n  2 │───┘ │ n -1 │──► x
 │   └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘     └──────┘
 │                                                                                              └────────────────────────────────┘
 │                                                                                                               ▲
 └───────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
```

Поменялись prev/next индексы:
- low.p = -1 , т.е арена #3 стала новым head
- tail.n = head.id , т.е. старый head стал рядовой ареной посередине очереди
- low-1.n = -1 , т.е. low-1 стало новым tail
- арены #0, #1, #2 стали свободными, т.к. теперь лежат после actual
- а буфер `buf` остался неизменным, никакого реального движения элементов в нём не произошло

При следующем цикле выселения произойдёт то же самое и несколько арен из начала очереди "сдвинутся" в конец очереди.
Этот крайне дешёвый трюк позволяет практически бесплатно управлять памятью кэша, не прибегая к сдвигам хранимых данных.
Причём, с точки зрения GC, очередь это примитивная структура с единственным слайсом арен и он не станет тратить время на
проверку/очистку данных очереди.

## Использование

Кэш инициализируется посредством заполнения специальной структуры [Config](https://github.com/koykov/cbytecache/blob/master/config.go#L10).
Ниже будут рассмотрены все поля конфига и даны объяснения как их изменение повлияет на поведение кэша.

### Capacity и ArenaCapacity

Параметры `Capacity` и `ArenaCapacity` задают соответственно общую ёмкость кэша и ёмкость каждой арены. Оба параметра
можно опустить, в этом случае кэш будет безразмерным, а ёмкость арены будет 16 КБ по умолчанию.

Задавать эти параметры можно посредством `MemorySize` [констант](https://github.com/koykov/cbytecache/blob/master/size.go#L9),
например так: `Capacity: cbytecache.Gigabyte * 5`.

### Hasher

Хранить ключи кэша в исходном строковом виде нецелесообразно, т.к. это указатели, а мы хотим избежать внимания GC.
Поэтому мы их преобразовываем в `uint64` хэши с помощью параметра `Hasher`. Он должен реализовывать одноимённый
интерфейс
```go
type Hasher interface {
	Sum64(string) uint64
}
```
и является обязательным параметром. Цель его наличия в конфиге - возможность повлиять на количество коллизий. Если
выбранный `Hasher` генерирурет слишком большое количество коллизий, то вы вольны выбрать другой.

### Buckets

Количество бакетов в кэше. Это обязательный параметр и он должен быть обязательно больше 0 и должен являться степенью
двойки. Не рекомендуется задавать очень большой размер для ненагруженных кэшей, т.к. это приведёт к перерасходу памяти.

### ExpireInterval

Этот параметр задаёт время жизни элементов кэша. Элемент старше этого значения получить из кэша будет уже невозможно,
при этом реальное выселение из кэша может наступить позже. Этот параметр является обязательным.
